#LyX 1.6.5 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options false
\language english
\inputencoding latin9
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
An Evolutionary Approach to Abalone
\end_layout

\begin_layout Author
Daniel Mescheder, Frans van den Heuvel, Achim Leydecker,
\begin_inset Newline newline
\end_inset

 Rutger van Driel, and Joren Vandelaer
\end_layout

\begin_layout Address
\align center
Department of Knowledge Engineering, Maastricht University
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Abstract
Abstract will go here.
\end_layout

\begin_layout Section
Introduction
\begin_inset CommandInset label
LatexCommand label
name "sec:Introduction"

\end_inset


\end_layout

\begin_layout Subsection
Background Information
\begin_inset CommandInset label
LatexCommand label
name "sub:Background-Information"

\end_inset


\end_layout

\begin_layout Standard
Testing the references.
\begin_inset CommandInset citation
LatexCommand cite
key "Abalearn1"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Abalearn2"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Abla1"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Lemmens1"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Chorus1"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Oswin1"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Benson1"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "MonteCarlo1,MonteCarlo2"

\end_inset


\end_layout

\begin_layout Subsection
The Game of Abalone
\begin_inset CommandInset label
LatexCommand label
name "sub:The-Game-of-Abalone"

\end_inset


\end_layout

\begin_layout Standard
In this section, the research subject will be introduced and it's rules
 will be explained briefly.
 Abalone - ranked with the 
\begin_inset Quotes eld
\end_inset

Game of the Decade
\begin_inset Quotes erd
\end_inset

 at the International Game Festival in 1998
\begin_inset CommandInset citation
LatexCommand cite
key "Abalearn1"

\end_inset

 - is a classical, strategic two-player board game.
 As many other classical board games, Abalone is a zero-sum game with perfect
 information.
 It is played on an hexagonal board (figure 1) on which there are two sets
 of fourteen marbles - one set for each player.
 
\end_layout

\begin_layout Standard
There are 2 types of moves a player can perform: An inline move during which
 a line of marbles is moved in the direction that the line faces (figure
 2) and a broadside move during which a line of marbles is moved to any
 other direction than the one the line faces (figure 3).
 Such a line may at most consist of three own marbles.
 With an inline move it is possible to 
\begin_inset Quotes eld
\end_inset

push
\begin_inset Quotes erd
\end_inset

 opponent marbles - such an action is then called a sumito move.
 However, this is only possible if the number of pushed marbles is less
 than the number of pushing marbles.
 That boils down to a total number of three possible types of sumito moves:
\end_layout

\begin_layout Enumerate
Two own marbles vs.
 one opponent marble.
\end_layout

\begin_layout Enumerate
Three own marbles vs.
 one opponent marble.
\end_layout

\begin_layout Enumerate
Three own marbles vs.
 two opponent marbles.
\end_layout

\begin_layout Standard
It is not allowed to perform suicidal moves - i.e.
 to push own marbles of the board.
 Moreover it is not possible to perform a sumito move is an own stone is
 in the way
\begin_inset Note Note
status open

\begin_layout Plain Layout
Todo: rephrase
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The following section will provide a sketch of research that has already
 been done on the subject of Abalone.
 Furthermore, our own reasearch questions will be stated.
\end_layout

\begin_layout Subsection
Research Questions
\begin_inset CommandInset label
LatexCommand label
name "sub:Research-Questions"

\end_inset


\end_layout

\begin_layout Standard
The game of Abalone has been subject to several scientific investigations.
 Lemmens implemented a minimax based agent playing abalone efficiently and
 compared various optimization methods
\begin_inset CommandInset citation
LatexCommand cite
key "Lemmens1"

\end_inset

, Chorus compared this tree search approach to a Monte Carlo technique
\begin_inset CommandInset citation
LatexCommand cite
key "Chorus1"

\end_inset

.
 Campos et al.
 achieved to create a self learning, advanced Abalone playing agent
\begin_inset CommandInset citation
LatexCommand cite
key "Abalearn1,Abalearn2"

\end_inset

.
\end_layout

\begin_layout Standard
In contrast to Campos who provided a machine learning algorithm for this
 task, Lemmens and Chorus left open the rationale behind their evaluation
 functions.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO stuff missing here
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This leads to the following research questions:
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Enumerate
Is it possible for an AI agent to play Abalone on a professional level?
\end_layout

\begin_layout Enumerate
Which heuristics are suited best for this problem?
\end_layout

\begin_layout Enumerate
Which machine learning techniques are best used to optimize the performance
 of the AI agent?
\end_layout

\begin_layout Plain Layout
This is the old version, new proposal (something we might be able to answer):
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Can board symmetries be taken into account to further enhance the performance
 of a minimax agent?
\end_layout

\begin_layout Enumerate
Is a Genetic Algrithm a feasible means to optimize an abalone evaluation
 function?
\end_layout

\begin_layout Enumerate
Which combination of todays commonly used atomary heuristics for the game
 of abalone is optimal?
\end_layout

\begin_layout Section
Complexity of Abalone
\begin_inset CommandInset label
LatexCommand label
name "sec:Complexity-of-Abalone"

\end_inset


\end_layout

\begin_layout Subsection
State-Space Complexity
\begin_inset CommandInset label
LatexCommand label
name "sub:State-Space-Complexity"

\end_inset


\end_layout

\begin_layout Standard
The state-space complexity of a game is the number of situations possible
 throughout a game.
 In general it is difficult to approximate the average state-space complexity
 of Abalone.
 Hence, an approximation for the upper bound number of possible game positions
 will be given instead.
\end_layout

\begin_layout Standard
Approximation of an upper bound for the number of possible game positions:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\sum_{k=8}^{14}\sum_{m=9}^{14}\frac{61!}{k!\left(61-k\right)!}\times\frac{\left(61-k\right)!}{m!\left(\left(61-k\right)-m\right)!}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\thickapprox7.8\times10^{24}\]

\end_inset


\end_layout

\begin_layout Standard
In the given approximation above 
\begin_inset Formula $k=8$
\end_inset

 represents the opponent player having 8 marbles left on the board out of
 a initial number of 14 marbles (i.e.
 opponent player has lost 6 marbles, the requirement for the game to end).
 Furthermore, 
\begin_inset Formula $m=9$
\end_inset

 represents the current player having 9 marbles left out of an initial number
 of 14 marbles (i.e.
 the minimum amount of marbles needed to be retained to not lose the game).
 The number 61 represents the number of positions on the board which can
 be occupied by marbles.
\begin_inset CommandInset citation
LatexCommand cite
key "Chorus1,Lemmens1"

\end_inset


\end_layout

\begin_layout Standard
Furthermore, when considering about Abalone's state-space complexity, symmetries
 must be taken into account: Abalone is played on a hexagonal board, as
 a result there are six mirrored and six rotated versions of the same state.
 This, however, means that the upper bound approximation can be divided
 by twelve, leading to the following, final approximation:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\thickapprox6.5\times10^{23}\]

\end_inset


\end_layout

\begin_layout Standard
In comparison with comparable boardgames, Abalone has a relatively low state-spa
ce complexity.
\begin_inset CommandInset citation
LatexCommand cite
key "Chorus1"

\end_inset


\end_layout

\begin_layout Subsection
Game-Tree Complexity
\begin_inset CommandInset label
LatexCommand label
name "sub:Game-Tree-Complexity"

\end_inset


\end_layout

\begin_layout Standard
The tree complexity of a game represents the number of possible move sequences
 and therefore constitutes an important measure for the applicability of
 tree search techniques.
\end_layout

\begin_layout Standard
Previous research into the game-tree complexity of Abalone has shown that
 the branching factor of Abalone to be around 60 â€“ 65.
 Furthermore the average game length for humans is around 87 ply humans
 and around 130 ply for computers
\begin_inset CommandInset citation
LatexCommand cite
key "Chorus1,Lemmens1"

\end_inset

.
 
\end_layout

\begin_layout Standard
It is difficult to approximate the game-tree complexity of Abalone.
 The most straight forward approximation is the lower bound calculation.
 This is achieved by taking the branching factor, 
\begin_inset Formula $b$
\end_inset

 , as the base, while setting the average-number of plies in a game, 
\begin_inset Formula $p$
\end_inset

 , as the exponent.
\end_layout

\begin_layout Standard
Approximation of an lower bound for the game-tree complexity:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
b^{p}=60^{87}=5.0\times10^{154}\]

\end_inset


\end_layout

\begin_layout Standard
In comparison with other boardgames, Abalone therefore has a high game-tree
 complexity.
\end_layout

\begin_layout Section
General Tree Searching Techniques
\begin_inset CommandInset label
LatexCommand label
name "sec:General-Tree-Searching"

\end_inset


\end_layout

\begin_layout Subsection
Tree Search
\begin_inset CommandInset label
LatexCommand label
name "sub:Tree-Search"

\end_inset


\end_layout

\begin_layout Standard
In this section it will be demonstrated, how standard tree search techniques
 as minimax search and alpha beta pruning can be applied to the game of
 Abalone.
 
\end_layout

\begin_layout Standard
As Abalone is a deterministic, full information zero sum game, it is suited
 well for the standard minimax search approach
\begin_inset CommandInset citation
LatexCommand cite
key "AIAMA"

\end_inset

.
 Minimax searching is based on the idea, that there are two opposing optimal
 players.
 One player tries to maximize the game outcome, which his opponent seeks
 to minimize.
 As sketched out in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Complexity-of-Abalone"

\end_inset

, Abalone's game tree is too complex to be searched completely by any known
 means.
 Instead a depth limited minimax search is introduced that cancels the minimax
 process at a certain depth.
 Moreover, as it is usually necessary to restrict an agent's consideration
 time, a time limited iterative deepening search is applied.
 Iteratively expanding the tree, this search strategy stops after a given
 time and returns the value found in the deepest completed search.
\end_layout

\begin_layout Standard
A minimax search can be further enhanced by alpha-beta pruning which hinders
 some nodes from being investigated if a player under the assumptions above
 would never choose for them anyway
\begin_inset CommandInset citation
LatexCommand cite
key "AIAMA"

\end_inset

.
 
\end_layout

\begin_layout Standard
The following sections will introduce more advanced optimization techniques
 that can be used to enhance the minimax tree search.
\end_layout

\begin_layout Subsubsection
Move Ordering
\begin_inset CommandInset label
LatexCommand label
name "sub:Move-Ordering"

\end_inset


\end_layout

\begin_layout Standard
As stated before, alpha-beta pruning as a standard optimization technique
 for minimax searches could successfully applied to the game of Abalone.
 It's real impact on efficiency, however, highly depends on the move ordering
 technique applied.
 Former research has shown that in the case of Abalone the following ordering
 was effective
\begin_inset CommandInset citation
LatexCommand cite
key "Chorus1"

\end_inset

:
\end_layout

\begin_layout Enumerate
3-marble push-off moves.
\end_layout

\begin_layout Enumerate
2-marble push-off moves.
\end_layout

\begin_layout Enumerate
3-marble sutemi moves.
\end_layout

\begin_layout Enumerate
2-marble sutemi moves.
\end_layout

\begin_layout Enumerate
3-marble inline moves.
\end_layout

\begin_layout Enumerate
2-marble inline moves.
\end_layout

\begin_layout Enumerate
3-marble broadside moves.
\end_layout

\begin_layout Enumerate
2-marble broadside moves.
\end_layout

\begin_layout Enumerate
Single marble moves.
\end_layout

\begin_layout Standard
This move ordering has led to a good performance of the alpha beta pruning.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
give results/statistics here
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Killer-Moves
\begin_inset CommandInset label
LatexCommand label
name "sub:Killer-Moves"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Is there anything to say about killer moves?
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Transposition Tables and Zobrist Hashing
\begin_inset CommandInset label
LatexCommand label
name "sub:Transposition-Tables"

\end_inset


\end_layout

\begin_layout Standard
In section
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Complexity-of-Abalone"

\end_inset

 it was pointed out that Abalone has a complex game tree while it's state
 space size is comparably modest.
 It is possible to conclude, that many states are reached by multiple branches.
 This section introduces transposition tables, which make use of this fact
 to prune some of the branches from the search tree
\begin_inset CommandInset citation
LatexCommand cite
key "AIAMA"

\end_inset

.
\end_layout

\begin_layout Standard
A famous transposition table implementation for board games is the so called
 Zobrist Hashing
\begin_inset CommandInset citation
LatexCommand cite
key "Chorus1"

\end_inset

.
 Let 
\begin_inset Formula \[
\text{hash}:\mathbb{F}\times\mathbb{A}\rightarrow\mathbb{Z}\]

\end_inset

be a function that maps a combination of a field on the board 
\begin_inset Formula $f\in\mathbb{F}$
\end_inset

 and a possible assignment 
\begin_inset Formula $a\in\mathbb{A}$
\end_inset

 to a individual hash-value (normally a 64 bit integer value).
 A state of the game is identified by a function 
\begin_inset Formula \[
\text{state}:\mathbb{F}\rightarrow\mathbb{A}\]

\end_inset

that maps each field of the board to it's current assignment.
 A Zobrist hash function is then defined as
\begin_inset Formula \[
\text{zobrist}\left(\text{state}\right)=\bigotimes_{f\in\mathbb{F}}\text{hash}\left(f,\text{state}\left(f\right)\right)\]

\end_inset

where 
\begin_inset Formula $\bigotimes$
\end_inset

 is the bitwise xor operation over the set of all hashes.
\end_layout

\begin_layout Standard
The Zobrist hash now serves as a quasi-unique identification of the state.
 A table can be set up with this identifier on the left hand side and the
 value of the state on the right hand side
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Actually there is a bit more to it.
 For example we furthermore need a value measuring the 
\begin_inset Quotes eld
\end_inset

level of detail
\begin_inset Quotes erd
\end_inset

 of our hash, that is, how deep we searched in order to calculate it.
 This article, however, does not aim to cover transposition tables in detail.
 More information and references can be found at http://chessprogramming.wikispac
es.com/Transposition+Table.
\end_layout

\end_inset

.
 When the same state is encountered a second time, it can be looked up in
 the table and its value can be returned immediately without any further
 investigation.
\end_layout

\begin_layout Subsubsection
Symmetry Aware Hashing
\begin_inset CommandInset label
LatexCommand label
name "sub:Symmetry-Aware-Hashing"

\end_inset


\end_layout

\begin_layout Standard
As explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Complexity-of-Abalone"

\end_inset

, an important factor that reduces the state-space in Abalone is the fact
 that there are twelve symmetric versions of every state.
 The standard Zobrist Hashing approach however does not take those symmetries
 into account.
 There are two main ideas that can lead to the desired, symmetry aware behavior:
\end_layout

\begin_layout Enumerate
Let the hashing work in such a way, that all symmetric versions of a state
 lead to the same hash value.
\end_layout

\begin_layout Enumerate
Provide a function that efficiently allows to conclude from a given hash
 to all the hashes of symmetric states and store them all in the hash table.
\end_layout

\begin_layout Standard
The latter approach has the disadvantage that the size of the transposition
 table grows by a factor that corresponds to the number of symmetries while
 the first approach comes with a potential computational overhead.
 The latter approach has successfully been applied to the game of go
\begin_inset CommandInset citation
LatexCommand cite
key "HuimaGroupZobrist"

\end_inset

.
 The main idea behind this symmetry aware hashing technique is, that the
 symmetries of the board graph form a dihedral group.
 The dihedral group can be constructed with two generating elements - in
 our case we can choose the clockwise rotation by one step 
\begin_inset Formula $\alpha$
\end_inset

 and the mirroring about the vertical axis 
\begin_inset Formula $\beta$
\end_inset

.
 The dihedral group of the Abalone board then consist of the following elements:
\begin_inset Formula \[
e,\alpha,\alpha^{2},\alpha^{3},\alpha^{4},\alpha^{5},\beta,\beta\alpha,\beta\alpha^{2},\beta\alpha^{3},\beta\alpha^{4},\beta\alpha^{5}\]

\end_inset

where 
\begin_inset Formula $e$
\end_inset

 is the identity transformation.
\end_layout

\begin_layout Standard
We now want to define a permutative group on our hashes which is isomorphic
 to the dihedral group of board symmetries.
 For this purpose two bitwise functions are used as generating elements:
\begin_inset Formula \[
\pi:\left(b_{1},b_{2},b_{3},b_{4},b_{5},b_{6},b_{7},b_{8}\right)\rightarrow\left(b_{1},b_{3},b_{4},b_{5},b_{6},b_{7},b_{2},b_{8}\right)\]

\end_inset


\begin_inset Formula \[
\rho:\left(b_{1},b_{2},b_{3},b_{4},b_{5},b_{6},b_{7},b_{8}\right)\rightarrow\left(b_{1},b_{7},b_{6},b_{5},b_{4},b_{3},b_{2},b_{8}\right)\]

\end_inset

where 
\begin_inset Formula $b_{i}$
\end_inset

 is the byte of the hash at position 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Standard
Observe, that 
\begin_inset Formula $\pi$
\end_inset

 behaves similar as 
\begin_inset Formula $\alpha$
\end_inset

 by 
\begin_inset Quotes eld
\end_inset

rotating
\begin_inset Quotes erd
\end_inset

 the hash in 6 steps, while 
\begin_inset Formula $\rho$
\end_inset

 behaves similar as 
\begin_inset Formula $\beta$
\end_inset

 by 
\begin_inset Quotes eld
\end_inset

mirroring
\begin_inset Quotes erd
\end_inset

 the hash
\begin_inset Foot
status open

\begin_layout Plain Layout
This is surely no proof for isomorphism.
 Group theoretic proofs, however, are beyond the scope of this article and
 therefore left out.
\end_layout

\end_inset

.
 What is important about bitwise permutations is that they are invariant
 under the xor operation.
 Therefore we know that
\begin_inset Formula \begin{equation}
\pi\left(\text{zobrist}\left(\text{state}\right)\right)=\pi\left(\bigotimes_{f\in\mathbb{F}}\text{hash}\left(f,\text{state}\left(f\right)\right)\right)=\bigotimes_{f\in\mathbb{F}}\pi\left(\text{hash}\left(f,\text{state}\left(f\right)\right)\right)\label{eq:pi-invariant-xor}\end{equation}

\end_inset


\begin_inset Formula \begin{equation}
\rho\left(\text{zobrist}\left(\text{state}\right)\right)=\rho\left(\bigotimes_{f\in\mathbb{F}}\text{hash}\left(f,\text{state}\left(f\right)\right)\right)=\bigotimes_{f\in\mathbb{F}}\rho\left(\text{hash}\left(f,\text{state}\left(f\right)\right)\right)\label{eq:rho-invariant-xor}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
We now define that 
\begin_inset Formula $\pi\left(\text{zobrist}\left(\text{state}\right)\right)=\text{zobrist\left(\alpha\circ\text{state}\right)}$
\end_inset

 and 
\begin_inset Formula $\rho\left(\text{zobrist}\left(\text{state}\right)\right)=\text{zobrist\left(\beta\circ state\right)}$
\end_inset

.
 With equations 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:pi-invariant-xor"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rho-invariant-xor"

\end_inset

 that yields the following expressions:
\begin_inset Formula \begin{equation}
zobrist\left(\alpha\circ\text{state}\right)=\bigotimes_{f\in\mathbb{F}}\pi\left(\text{hash}\left(f,\text{state}\left(f\right)\right)\right)=\bigotimes_{f\in\mathbb{F}}\text{hash}\left(f,\alpha\circ\text{state}\left(f\right)\right)\label{eq:alpha-pi-equality}\end{equation}

\end_inset


\begin_inset Formula \begin{equation}
zobrist\left(\beta\circ\text{state}\right)=\bigotimes_{f\in\mathbb{F}}\rho\left(\text{hash}\left(f,\text{state}\left(f\right)\right)\right)=\bigotimes_{f\in\mathbb{F}}\text{hash}\left(f,\beta\circ\text{state}\left(f\right)\right)\label{eq:beta-rho-equality}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The most straightforward way to satisfy 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:alpha-pi-equality"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:beta-rho-equality"

\end_inset

is to put the following constraint on the 
\begin_inset Formula $\text{hash}\left(f,a\right)$
\end_inset

 function: 
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\text{hash}\left(f_{1},a\right)=\pi\left(\text{hash}\left(f_{2},a\right)\right)$
\end_inset

 if and only if 
\begin_inset Formula $\alpha\circ\text{state}\left(f_{2}\right)=\text{state\left(f_{1}\right)}$
\end_inset

 for all states.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\text{hash}\left(f_{1},a\right)=\rho\left(\text{hash}\left(f_{2},a\right)\right)$
\end_inset

 if and only if 
\begin_inset Formula $\beta\circ\text{state}\left(f_{2}\right)=\text{state\left(f_{1}\right)}$
\end_inset

 for all states.
\end_layout

\begin_layout Standard
As long as we know that those constraints are valid for our hash function,
 we can easily apply 
\begin_inset Formula $\pi$
\end_inset

 and 
\begin_inset Formula $\rho$
\end_inset

 on a known hash in order to get all it's symmetries.
 The problem that remains is how to enforce those constraints.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename abalone-board-symmetries.dia
	width 40col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Symmetries of the Abalone board.
\begin_inset CommandInset label
LatexCommand label
name "fig:Symmetries"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Looking at the board in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Symmetries"

\end_inset

 reveals that there are two classes of symmetry axes - the ones that are
 odd numbered and marked by a light green line and the ones that are even
 numbered and marked by a dark green line.
 For the yellow nodes on the horizontal axis (1), we can apply the following
 constraint:
\begin_inset Formula \[
\beta=\alpha^{3}\]

\end_inset

which means that 
\begin_inset Formula $\rho=\pi^{3}$
\end_inset

.
 Looking at what this means for the bitwise permutation we get the following
 condition:
\begin_inset Formula \begin{eqnarray*}
\left(b_{1},b_{7},b_{6},b_{5},b_{4},b_{3},b_{2},b_{8}\right) & = & \left(b_{1},b_{5},b_{6},b_{7},b_{2},b_{3},b_{4},b_{8}\right)\end{eqnarray*}

\end_inset

which gives us
\begin_inset Formula \begin{eqnarray*}
b_{7} & = & b_{5}\\
b_{4} & = & b_{2}\end{eqnarray*}

\end_inset

so that we can derive the structure of the hashes on axis (1):
\begin_inset Formula \[
\left(b_{1},b_{2},b_{3},b_{2},b_{4},b_{5},b_{4},b_{6}\right)\]

\end_inset


\end_layout

\begin_layout Standard
Similarly we can derive the hash structures of axes (3) and (5):
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(b_{1},b_{2},b_{3},b_{4},b_{5},b_{4},b_{3},b_{6}\right)$
\end_inset

 for axis (3)
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(b_{1},b_{2},b_{3},b_{4},b_{3},b_{2},b_{5},b_{6}\right)$
\end_inset

 for axis (5)
\end_layout

\begin_layout Standard
The constraint we find on axis (4) is that 
\begin_inset Formula $\beta=e$
\end_inset

.
 Using the same approach as above we can derive the following structures:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(b_{1},b_{2},b_{3},b_{4},b_{4},b_{3},b_{2},b_{5}\right)$
\end_inset

 for axis (4)
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(b_{1},b_{2},b_{3},b_{3},b_{2},b_{4},b_{4},b_{5}\right)$
\end_inset

 for axis (6)
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(b_{1},b_{2},b_{2},b_{3},b_{4},b_{4},b_{3},b_{5}\right)$
\end_inset

 for axis (2)
\end_layout

\begin_layout Standard
Note that the structures actually allow us to apply 
\begin_inset Formula $\pi$
\end_inset

 three times on every node of one axis of each class in order to assign
 the correctly constrained values.
 Note also that we reduced the effective hash size to six byte on axis (1),
 (3) and (5) and to five byte on axis (2), (4) and (6).
\end_layout

\begin_layout Standard
There is one more special case, namely the central node whose hash has to
 stay invariant under 
\begin_inset Formula $\pi$
\end_inset

 and 
\begin_inset Formula $\rho$
\end_inset

.
 We therefore simply assign it a value with the structure 
\begin_inset Formula $\left(b_{1},b_{2},b_{2},b_{2},b_{2},b_{2},b_{2},b_{3}\right)$
\end_inset

.
 The hashes of the remaining nodes (colored blue in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Symmetries"

\end_inset

) are easily generated by generating random eight byte values and applying
 
\begin_inset Formula $\pi$
\end_inset

 and 
\begin_inset Formula $\rho$
\end_inset

 to derive all symmetries.
\end_layout

\begin_layout Standard
This section demonstrated how treesearch techniques based on the minimax
 algorithm can be applied to Abalone and introduced some techniques for
 optimization.
 The following section will elaborate on what to do at the depth limit of
 a minimax search by providing some evaluation techniques.
\end_layout

\begin_layout Subsection
Evaluation Functions
\begin_inset CommandInset label
LatexCommand label
name "sub:Evaluation-Functions"

\end_inset


\end_layout

\begin_layout Subsubsection
Introduction to Evaluation Functions
\begin_inset CommandInset label
LatexCommand label
name "sub:Intro-Evaluation-Functions"

\end_inset


\end_layout

\begin_layout Standard
In section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:General-Tree-Searching"

\end_inset

 the practicalities of searching a game tree with a high game-tree complexity
 are brought to light.
 It was pointed out, that, in practice, a search can only go to a certain
 depth, before it has to analyze the situation and make a decision.
 The question which arises is, how to judge the quality of a possible move
 given that they do not know the end state? A solution to this is the use
 an evaluation function which estimates the value of a position in a search.
 
\end_layout

\begin_layout Standard
When constructing an evaluation function for an agent playing Abalone, it
 makes sense to consider general strategies commonly used.
 Below is a list of strategies that are widely accepted as appropriate rules
 of thumb:
\begin_inset Note Note
status open

\begin_layout Plain Layout
Source?
\end_layout

\end_inset

:
\end_layout

\begin_layout Itemize
Keep your own marbles at the center of the board, while keeping opponent
 marbles at the outside of the board.
\end_layout

\begin_layout Itemize
Keep your own marbles together.
\end_layout

\begin_layout Itemize
Strengthen groups of marbles that are in contact with opponent marbles.
 
\end_layout

\begin_layout Itemize
Split up your opponent's marble lines.
\end_layout

\begin_layout Subsubsection
Linear Evaluator
\begin_inset CommandInset label
LatexCommand label
name "sub:Lemmen's-Evaluator"

\end_inset


\end_layout

\begin_layout Standard
This section introduces a weighted linear evaluator based on the general
 strategies layed out in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Intro-Evaluation-Functions"

\end_inset

 and Lemmens' results
\begin_inset CommandInset citation
LatexCommand cite
key "Lemmens1"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Todo: Introduce the equation somehow
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
eval(s)=\sum_{i=1}^{6}w_{i}\times f_{i}(s)\]

\end_inset

where
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
\begin_inset Formula $f_{1}(s)$
\end_inset

 is the difference between the sum of the Manhattan distances for every
 marble for each player, for a given board state 
\emph on
s (center strategy
\emph default
),
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
\begin_inset Formula $f_{2}(s)$
\end_inset

 is the difference between the sum of the number of neighboring teammates
 for every marble for each player, for a given board state 
\emph on
s
\emph default
 (
\emph on
cohesion strategy
\emph default
),
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
\begin_inset Formula $f_{3}(s)$
\end_inset

 is the difference between the sum of having an opponent marble at one adjacent
 side of a player's marble and having an opponent marble at the opposing
 adjacent side, for a given board state 
\emph on
s
\emph default
 
\emph on
(break strong group strategy
\emph default
), 
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
\begin_inset Formula $f_{4}(s)$
\end_inset

 is the difference between the sum of having an opponent marble at one adjacent
 side of a player's marble and having an teammate marble at the opposing
 adjacent side, for a given board state 
\emph on
s (strengthen group strategy),
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
\begin_inset Formula $f_{5}(s)$
\end_inset

 is the number of lost marbles of the opponent player, for a given board
 state 
\emph on
s
\emph default
 
\emph on
(taken marble strategy),
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
\begin_inset Formula $f_{6}(s)$
\end_inset

 is the number of lost marbles of the current player, for a given board
 state 
\emph on
s
\emph default
 (
\emph on
lost marble strategy
\emph default
).
\end_layout

\begin_layout Subsubsection
Non-Linear Evaluator
\begin_inset CommandInset label
LatexCommand label
name "sub:Non-Linear-Evaluator"

\end_inset


\end_layout

\begin_layout Section
Genetic Algorithm
\begin_inset CommandInset label
LatexCommand label
name "sec:Genetic-Algorithm"

\end_inset


\end_layout

\begin_layout Standard
The previous section examined evaluators that can form the basis of decisionmaki
ng for an Abalone player.
 However, the performance of the agent highly depends on the weighting of
 the individual evaluation functions.
 This section discusses the use of a genetic algorithm (the use of machine
 learning techniques
\begin_inset Note Note
status open

\begin_layout Plain Layout
How is that meant?
\end_layout

\end_inset

) to optimize these weights.
\end_layout

\begin_layout Standard
A genetic algorithm is a stochastic hill-climbing technique that models
 natural selection to solve optimization problems
\begin_inset CommandInset citation
LatexCommand cite
key "AIAMA"

\end_inset

.
 Analogue to the biological theory of evolution whose main idea is that
 in a competitive environment, fitter organisms have an increased chance
 to pass their genetic information to succeeding generations, individuals
 of a population of a genetic algorithm are assigned a fitness value that
 decides whether it will be passed to the succeeding generation.
\end_layout

\begin_layout Standard
Accordingly, the genetic individuals in this problem represent Abalone agents
 that are distinct by their genome, i.e.
 the weights used for their evaluation function.
 The fitness of the individuals is determined in matches with their peers
 in a competition/tournament.
 In the transition of one population of individuals to its successor, some
 of the individuals are selected to reproduce themselves and mutate to generate
 the new population of individuals.
 The type of tournament, selection method, reproduction method and the mutation
 method can be varied and adapted to the problem.
 A more detailed description of the design of the experiments follows in
 section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:GA-Design"

\end_inset

.
\end_layout

\begin_layout Itemize
why use a genetic algorithm?
\end_layout

\begin_layout Subsection
Design
\begin_inset CommandInset label
LatexCommand label
name "sub:GA-Design"

\end_inset


\end_layout

\begin_layout Subsubsection
Scaling of the weights/ reproduction
\begin_inset CommandInset label
LatexCommand label
name "sub:Scaling-of-weights"

\end_inset


\end_layout

\begin_layout Standard
As mentioned, the weights compose the genome of a genetic individual.
 Since the evaluation functions are scaled, the weights express the relative
 importance of individual evaluation functions.
 During the reproduction process, a new individual is created by combining
 single genes or blocks of genes of parent individuals to form a new genome.
 However, the absolute values of the weights are only representative in
 the context of their original genome.
 The important information, that is the relative proportion of the value
 of a gene to the values of the other genes of a genome, is not inherited
 in this way.
 By scaling the sum of the absolute values of a genome to 1, the absolute
 value of a gene represents the proportion that the corresponding evaluation
 function occupies in its evaluator.
 Thus, a scaled gene transfers this information if it is inherited.
\end_layout

\begin_layout Standard
(Of course, the genome of a reproduced individual has to be rescaled after
 its creation + explanation)
\end_layout

\begin_layout Subsubsection
Mutation
\begin_inset CommandInset label
LatexCommand label
name "sub:Mutation"

\end_inset


\end_layout

\begin_layout Subsubsection
Fitness function
\begin_inset CommandInset label
LatexCommand label
name "sub:Fitness-function"

\end_inset


\end_layout

\begin_layout Itemize
should give feedback on the performance of an agent during a match
\end_layout

\begin_layout Itemize
problem: Abalone games can be infinite
\end_layout

\begin_deeper
\begin_layout Itemize
how to evaluate performance after ply limit is reached?
\end_layout

\begin_layout Itemize
can this be done unbiased (e.g.
 fitness plus for pushed marbles --> offensive player)
\end_layout

\begin_layout Itemize
how to avoid loops
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

conservative
\begin_inset Quotes erd
\end_inset

 character of abalone --> very few pushes with randomly initialized individuals
\end_layout

\end_deeper
\begin_layout Subsection
Implementation
\begin_inset CommandInset label
LatexCommand label
name "sub:GA-Implementation"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Can we completely leave that out?
\end_layout

\begin_layout Section
Opponent Modeling
\begin_inset CommandInset label
LatexCommand label
name "sec:Opponent-Modeling"

\end_inset


\end_layout

\begin_layout Plain Layout
Normal minimax-search assumes the opponent will always make the optimal
 moves for him.
 Minimax-search assumes the opponent is using the same evaluation function.
 With human opponents this is never the case but because the AI presumes
 the evaluation function is optimal, the human can only make worse decisions
 than the ones the AI had envisioned for him.
 With opponent modeling the OM-search AI tries to get a greater advantage
 from the fact that the opponent makes sub-optimal moves (according to the
 minimax algorithm).
 The AI with opponent modeling tries to get optimal outcomes knowing that
 the opponent will make sub-optimal moves.
 This approach has the risk that if the opponent model is wrong and the
 AI wrongly predicts the opponents move, there is a high probability he
 will make a worse move than if he used the minimax-algorithm.
 
\end_layout

\begin_layout Subsection
Design
\begin_inset CommandInset label
LatexCommand label
name "sub:OpponentModeling-Design"

\end_inset


\end_layout

\begin_layout Plain Layout
There is a difference between opponents that are already know and there
 is a model of and opponents never seen before without any known model.
 If the opponent is already known its model can be loaded into a OM-search
 AI that will incorporate the model in his search.
 If the opponent is not known, the AI tries to adjust our evaluation function
 to emulate how the opponent makes his moves and create a model of the opponent.
 This way the AI tries to make a model of the opponent which is compatible
 with the agent's own model and can be incorporated in the OM-search.
 This will not be a perfect model of the opponents decision algorithm but
 it can be assumed that the opponents decision algorithm is a minimax search
 with the same (or parts of) our evaluation function.
 The opponents evaluation function (model) is only a small variation of
 the OM-search agent's evaluation function so there is no big risk that
 he will make a much worse move (when the OM-search AI predicts the wrong
 move) than if normal minimax-search would have been used.
 
\end_layout

\begin_layout Plain Layout
The OM-search AI can make moves that might be suboptimal in normal minimax-searc
h but will give the new AI an advantage because the opponent will do a suboptima
l move which, in the end, has a higher evaluation for the OM-search AI.
 
\end_layout

\begin_layout Plain Layout
OM-search works with a separate evaluation function (model) for the opponent
 and for himself.
 It is very similar to minimax-search but the algorithm stores both the
 evaluation-outcomes at every node.
 Now at all minus-nodes the AI will take the path with the lowest outcome
 for the opponents evaluation and at the max-nodes he will pick the path
 with the highest outcome for his own evaluation function (the same as the
 outcome you would have had with the minimax algorithm).[ref: Opponent Models
 and Knowledge Symmetry in Game-Tree Search]
\end_layout

\begin_layout Subsection
Implementation
\begin_inset CommandInset label
LatexCommand label
name "sub:OpponentModeling-Implementation"

\end_inset


\end_layout

\begin_layout Plain Layout
In our implementation a opponent-model consists of the weights of the evaluation
 function, similar to the individuals of our genetic algorithm.
 There are models that are pre-set and differ slightly from our own evaluation
 function in that they are more aggressive or more defensive, more or less
 risk.
 Sometimes the AI does not know anything about the opponent.
 In that case the opponents model starts out as a replica of the agent's
 weights but they get changed bit by bit for every decision the opponent
 makes differently that the OM-search AI thought he would do.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Experimental Setup
\begin_inset CommandInset label
LatexCommand label
name "sec:Experiments-Setup"

\end_inset


\end_layout

\begin_layout Subsection
Tree Search Performance
\begin_inset CommandInset label
LatexCommand label
name "sub:Setup-Tree-Search-Performance"

\end_inset


\end_layout

\begin_layout Standard
The experimental setup for the tree search performance aimed at measuring
 two criteria:
\end_layout

\begin_layout Enumerate
The time needed for a search run of a certain depth.
\end_layout

\begin_layout Enumerate
The nodes investigated during a search run of a certain depth.
\end_layout

\begin_layout Standard
While the latter criterion has the advantage of being independent of implementat
ions issues and more reproducible, the former criterion also takes into
 account overhead that might have been added by certain pruning techniques.
\end_layout

\begin_layout Standard
The problem of those measurements in the game of Abalone is, that the complexity
 of a search strongly depends on several factors different from the applied
 optimization, as for example the number of possible moves in a state.
 To overcome this issue and provide a reliable result, multiple distinct
 statistics are collected:
\end_layout

\begin_layout Enumerate
The results of a search from the start position.
\end_layout

\begin_layout Enumerate
The results of a search from a typical in-game situation.
\end_layout

\begin_layout Enumerate
The averaged result of multiple searches throughout a game.
\end_layout

\begin_layout Standard
Having established the test strategy, it can be applied to the optimization
 techniques described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:General-Tree-Searching"

\end_inset

 including alpha-beta pruning, move ordering, Zobrist hashing and symmetry
 aware hashing.
\end_layout

\begin_layout Standard
The results are given in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Result-Tree-Search-Performance"

\end_inset

.
\end_layout

\begin_layout Subsection
Training of the Evaluation Function
\begin_inset CommandInset label
LatexCommand label
name "sub:Setup-Training-of-the-Evaluation"

\end_inset


\end_layout

\begin_layout Standard
In section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:GA-Design"

\end_inset

 the parameters of the genetic algorithm were presented.
 This section introduces the experimental setups used to determine the settings
 best suited to let the algorithm converge to a dominant strategy.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="6">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Testrun
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reproduction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Selection
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tournament
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Match
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Search
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\text{Pairwise}(2,4)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
best 5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $T_{1}(10)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
max.
 200 ply
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S_{1}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\text{Pairwise}(2,2)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
best 7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $T_{1}(3)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
max.
 200 ply
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S_{1}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\text{Pairwise}(5,2)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
best 10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $T_{1}(5)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
max.
 200 ply
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S_{1}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\text{Pairwise}(2,4)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
best 10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $T_{2}(2)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
200 / 260ply
\begin_inset Foot
status open

\begin_layout Plain Layout
260 can occur through overtime, refer to section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Fitness-function"

\end_inset


\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S_{1}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\text{Pairwise}(2,4)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
best 5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $T_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
max 200 ply
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Test run settings for the genetic algorithm.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Overall AI Performance
\begin_inset CommandInset label
LatexCommand label
name "sub:Setup-AI-Performance"

\end_inset


\end_layout

\begin_layout Enumerate
Our AI vs ABA-PRO*
\end_layout

\begin_layout Enumerate
Our AI vs Random Software Abalone*
\end_layout

\begin_layout Enumerate
Out AI vs NetAbalone* 
\end_layout

\begin_layout Section
Results of Experiments
\begin_inset CommandInset label
LatexCommand label
name "sec:Results"

\end_inset


\end_layout

\begin_layout Subsection
Tree Search Performance
\begin_inset CommandInset label
LatexCommand label
name "sub:Result-Tree-Search-Performance"

\end_inset


\end_layout

\begin_layout Standard
In this section the results of experimental setup described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Setup-Tree-Search-Performance"

\end_inset

 will be given, interpreted and compared to the results from previous research.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-result-of-hashing"

\end_inset

 shows the result of the various hashing strategies...
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Provide more statistics here.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename graph_treesearch_complexity_comparison.png
	lyxscale 50
	width 50col%

\end_inset


\begin_inset Graphics
	filename graph_treesearch_time_comparison.png
	lyxscale 50
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
In this figure various optimization strategies are compared at the initial
 state of Abalone.
 Shown is: the number of nodes that were investigated and the runtime of
 the search.
 Note, that the strategies without alpha-beta pruning could not be applied
 for a search on level five because of hardware restrictions.
\begin_inset CommandInset label
LatexCommand label
name "fig:Comparison-Startposition"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename symmetric_hashing-vs-normal_hashing.png
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The improvement of symmetric hashing over normal hashing at the initial
 position compared by time and investigated nodes.
\begin_inset CommandInset label
LatexCommand label
name "fig:The-result-of-hashing"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename graph_treesearch_complexity_comparison_ingame.png
	lyxscale 50
	width 50col%

\end_inset


\begin_inset Graphics
	filename graph_treesearch_time_comparison_ingame.png
	lyxscale 50
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
In this figure various optimization strategies are compared at a chosen
 ingame state of Abalone.
 Shown is: the number of nodes that were investigated and the runtime of
 the search.
 Note, that the strategies without alpha-beta pruning could not be applied
 to searches of 4 or 5 ply because of hardware restrictions.
\begin_inset CommandInset label
LatexCommand label
name "fig:Comparison-Ingame"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Training of the Evaluation Function
\begin_inset CommandInset label
LatexCommand label
name "sub:Result-Training-of-the-Evaluation"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename graph_ga_01.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The result of a training run.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Overall AI Performance
\begin_inset CommandInset label
LatexCommand label
name "sub:Result-Overal-AI-Performance"

\end_inset


\end_layout

\begin_layout Section
Conclusions
\begin_inset CommandInset label
LatexCommand label
name "sec:Conclusions"

\end_inset


\end_layout

\begin_layout Section
Discussion and Further Research
\begin_inset CommandInset label
LatexCommand label
name "sec:Further-Research"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "bibliography"
options "bibtotoc,apalike2"

\end_inset


\end_layout

\begin_layout Section
\start_of_appendix
Result Tables for the Experimental Results
\end_layout

\begin_layout Subsection
Tree Search Performance
\end_layout

\begin_layout Subsection
Training of the Evaluation Function
\end_layout

\end_body
\end_document
