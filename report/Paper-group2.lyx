#LyX 1.6.5 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options false
\language english
\inputencoding latin9
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Abalone
\end_layout

\begin_layout Author
Daniel Mescheder, Frans van den Heuvel, Achim Leydecker,
\begin_inset Newline newline
\end_inset

 Rutger van Driel, and Joren Vandelaer
\end_layout

\begin_layout Address
\align center
Department of Knowledge Engineering, Maastricht University
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Abstract
Abstract will go here.
\end_layout

\begin_layout Section
Introduction
\begin_inset CommandInset label
LatexCommand label
name "sec:Introduction"

\end_inset


\end_layout

\begin_layout Subsection
Background Information
\begin_inset CommandInset label
LatexCommand label
name "sub:Background-Information"

\end_inset


\end_layout

\begin_layout Standard
Testing the references.
\begin_inset CommandInset citation
LatexCommand cite
key "Abalearn1"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Abalearn2"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Abla1"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Lemmens1"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Chorus1"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Oswin1"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Benson1"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "MonteCarlo1,MonteCarlo2"

\end_inset


\end_layout

\begin_layout Subsection
The Game of Abalone
\begin_inset CommandInset label
LatexCommand label
name "sub:The-Game-of"

\end_inset


\end_layout

\begin_layout Standard
Abalone is a two-person zero-sum board game, with perfect information.
 The goal of the game is to remove 6 opponent marbles from the hexagonal
 board.
 
\end_layout

\begin_layout Subsection
Research Questions
\begin_inset CommandInset label
LatexCommand label
name "sub:Research-Questions"

\end_inset


\end_layout

\begin_layout Standard
The following are possible research questions:
\end_layout

\begin_layout Enumerate
Is it possible for an AI agent to play Abalone on a professional level?
\end_layout

\begin_layout Enumerate
Which heuristics are suited best for this problem?
\end_layout

\begin_layout Enumerate
Which machine learning techniques are best used to optimize the performance
 of the AI agent?
\end_layout

\begin_layout Enumerate
Which type of opponent modeling will improve the performance?
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Complexity of Abalone
\begin_inset CommandInset label
LatexCommand label
name "sec:Complexity-of-Abalone"

\end_inset


\end_layout

\begin_layout Subsection
State-Space Complexity
\begin_inset CommandInset label
LatexCommand label
name "sub:State-Space-Complexity"

\end_inset


\end_layout

\begin_layout Standard
Approximation of an upper bound for the number of possible game positions:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\sum_{k=8}^{14}\sum_{m=9}^{14}\frac{61!}{k!\left(61-k\right)!}\times\frac{\left(61-k\right)!}{m!\left(\left(61-k\right)-m\right)!}\]

\end_inset


\end_layout

\begin_layout Itemize
The number 14 represents the amount of marbles which each player starts
 with.
\end_layout

\begin_layout Itemize
The number 61 represents the slots on the board.
 
\end_layout

\begin_layout Itemize
k = 8 is for the opposite player the minimum when it looses.
 
\end_layout

\begin_layout Itemize
m = 9 is for the player, to ensure it does not loose.
\end_layout

\begin_layout Standard
Overall a relatively low state-space complexity.
\end_layout

\begin_layout Subsection
Game-Tree Complexity
\begin_inset CommandInset label
LatexCommand label
name "sub:Game-Tree-Complexity"

\end_inset


\end_layout

\begin_layout Standard
From research it was discovered that the branching factor of Abalone to
 be around 60 â€“ 65.
 The average game length for humans is around 87 ply humans and around 130
 ply for computers.
 
\end_layout

\begin_layout Standard
Lower bound: 
\begin_inset Formula $60^{87}=5.0\times10^{154}$
\end_inset


\end_layout

\begin_layout Standard
Upper bound: 
\begin_inset Formula $65^{130}=4.77\times10^{235}$
\end_inset


\end_layout

\begin_layout Standard
Overall a high game-tree complexity.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
General Tree Searching Techniques
\begin_inset CommandInset label
LatexCommand label
name "sec:General-Tree-Searching"

\end_inset


\end_layout

\begin_layout Subsection
Tree Search
\begin_inset CommandInset label
LatexCommand label
name "sub:Tree-Search"

\end_inset


\end_layout

\begin_layout Standard
In this section it will be demonstrated, how standard tree search techniques
 as minimax search and alpha beta pruning can be applied to the game of
 abalone.
 
\end_layout

\begin_layout Standard
As abalone is a deterministic, full information zero sum game, it is suited
 well for the standard minimax search approach
\begin_inset CommandInset citation
LatexCommand cite
key "AIAMA"

\end_inset

.
 Minimax searching is based on the idea, that there are two opposing optimal
 players.
 One player tries to maximize the game outcome, which his opponent seeks
 to minimize.
 A minimax search can be further enhanced by alpha-beta pruning which hinders
 some nodes from being investigated if they would not be valuable under
 the above assumptions anyway.
 
\end_layout

\begin_layout Standard
Abalone's search tree is too complex to be searched completely by any known
 means.
 Instead a depth limited minimax search is introduced that cancels the search
 process at a certain depth.
 Moreover, as it is usually necessary to restrict the consideration time
 of an AI needs, a time limited iterative deepening search was used.
 Iteratively expanding the tree, this search strategy stops after a given
 time and returns the most detailed value found.
\end_layout

\begin_layout Standard
The following sections will introduce more advanced optimization techniques
 that can be used to enhance the minimax tree search.
\end_layout

\begin_layout Subsubsection
Move Ordering
\begin_inset CommandInset label
LatexCommand label
name "sub:Move-Ordering"

\end_inset


\end_layout

\begin_layout Standard
As stated before, alpha-beta pruning as a standard optimization technique
 for minimax searches could successfully applied to the game of abalone.
 It's real impact on efficiency, however, highly depends on the move ordering
 technique applied.
 Former research has shown that in the case of abalone the following ordering
 was effective
\begin_inset CommandInset citation
LatexCommand cite
key "Chorus1"

\end_inset

:
\end_layout

\begin_layout Enumerate
3-marble push-off moves.
\end_layout

\begin_layout Enumerate
2-marble push-off moves.
\end_layout

\begin_layout Enumerate
3-marble sutemi moves.
\end_layout

\begin_layout Enumerate
2-marble sutemi moves.
\end_layout

\begin_layout Enumerate
3-marble inline moves.
\end_layout

\begin_layout Enumerate
2-marble inline moves.
\end_layout

\begin_layout Enumerate
3-marble broadside moves.
\end_layout

\begin_layout Enumerate
2-marble broadside moves.
\end_layout

\begin_layout Enumerate
Single marble moves.
\end_layout

\begin_layout Standard
This move ordering has led to a good performance of the alpha beta pruning.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
give results/statistics here
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Killer-Moves
\begin_inset CommandInset label
LatexCommand label
name "sub:Killer-Moves"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Is there anything to say about killer moves?
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Transposition Tables and Zobrist Hashing
\begin_inset CommandInset label
LatexCommand label
name "sub:Transposition-Tables"

\end_inset


\end_layout

\begin_layout Standard
In section
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Complexity-of-Abalone"

\end_inset

 it was pointed out that abalone has a complex game tree while it's state
 space size is comparably modest.
 It is possible to conclude, that many states are reached by multiple branches.
 This section introduces transposition tables, which make use of this fact
 to prune some of the branches from the search tree
\begin_inset CommandInset citation
LatexCommand cite
key "AIAMA"

\end_inset

.
\end_layout

\begin_layout Standard
A famous transposition table implementation for board games is the so called
 Zobrist Hashing
\begin_inset CommandInset citation
LatexCommand cite
key "Chorus1"

\end_inset

.
 Let 
\begin_inset Formula \[
\text{hash}:\mathbb{F}\times\mathbb{A}\rightarrow\mathbb{Z}\]

\end_inset

be a function that maps a combination of a field on the board 
\begin_inset Formula $f\in\mathbb{F}$
\end_inset

 and a possible assignment 
\begin_inset Formula $a\in\mathbb{A}$
\end_inset

 to a individual hash-value (normally a 64 bit integer value).
 A state of the game is identified by a function 
\begin_inset Formula \[
\text{state}:\mathbb{F}\rightarrow\mathbb{A}\]

\end_inset

that maps each field of the board to it's current assignment.
 A Zobrist hash function is then defined as
\begin_inset Formula \[
\text{zobrist}\left(\text{state}\right)=\bigotimes_{f\in\mathbb{F}}\text{hash}\left(f,\text{state}\left(f\right)\right)\]

\end_inset

where 
\begin_inset Formula $\bigotimes$
\end_inset

 is the bitwise xor operation over the set of all hashes.
\end_layout

\begin_layout Standard
The Zobrist hash now serves as a quasi-unique identification of the state.
 A table can be set up with this identifier on the left hand side and the
 value of the state on the right hand side
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Actually there is a bit more to it.
 For example we furthermore need a value measuring the 
\begin_inset Quotes eld
\end_inset

level of detail
\begin_inset Quotes erd
\end_inset

 of our hash, that is, how deep we searched in order to calculate it.
 This article, however, does not aim to cover transposition tables in detail.
 More information and references can be found at http://chessprogramming.wikispac
es.com/Transposition+Table.
\end_layout

\end_inset

.
 When the same state is encountered a second time, it can be looked up in
 the table and its value can be returned immediately without any further
 investigation.
\end_layout

\begin_layout Subsubsection
Symmetry Aware Hashing
\begin_inset CommandInset label
LatexCommand label
name "sub:Symmetry-Aware-Hashing"

\end_inset


\end_layout

\begin_layout Standard
As explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Complexity-of-Abalone"

\end_inset

, an important factor that reduces the state-space in abalone is the fact
 that there are twelve symmetric versions of every state.
 The standard Zobrist Hashing approach however does not take those symmetries
 into account.
 There are two main ideas that can lead to the desired, symmetry aware behavior:
\end_layout

\begin_layout Enumerate
Let the hashing work in such a way, that all symmetric versions of a state
 lead to the same hash value.
\end_layout

\begin_layout Enumerate
Provide a function that efficiently allows to conclude from a given hash
 to all the hashes of symmetric states and store them all in the hash table.
\end_layout

\begin_layout Standard
The latter approach has the disadvantage that the size of the transposition
 table grows by a factor that corresponds to the number of symmetries while
 the first approach comes with a potential computational overhead.
 The latter approach has successfully been applied to the game of go
\begin_inset CommandInset citation
LatexCommand cite
key "HuimaGroupZobrist"

\end_inset

.
 The main idea behind this symmetry aware hashing technique is, that the
 symmetries of the board graph form a dihedral group.
 The dihedral group can be constructed with two generating elements - in
 our case we can choose the clockwise rotation by one step 
\begin_inset Formula $\alpha$
\end_inset

 and the mirroring about the vertical axis 
\begin_inset Formula $\beta$
\end_inset

.
 The dihedral group of the abalone board then consist of the following elements:
\begin_inset Formula \[
e,\alpha,\alpha^{2},\alpha^{3},\alpha^{4},\alpha^{5},\beta,\beta\alpha,\beta\alpha^{2},\beta\alpha^{3},\beta\alpha^{4},\beta\alpha^{5}\]

\end_inset

where 
\begin_inset Formula $e$
\end_inset

 is the identity transformation.
\end_layout

\begin_layout Standard
We now want to define a permutative group on our hashes which is isomorphic
 to the dihedral group of board symmetries.
 For this purpose two bitwise functions are used as generating elements:
\begin_inset Formula \[
\pi:\left(b_{1},b_{2},b_{3},b_{4},b_{5},b_{6},b_{7},b_{8}\right)\rightarrow\left(b_{1},b_{3},b_{4},b_{5},b_{6},b_{7},b_{2},b_{8}\right)\]

\end_inset


\begin_inset Formula \[
\rho:\left(b_{1},b_{2},b_{3},b_{4},b_{5},b_{6},b_{7},b_{8}\right)\rightarrow\left(b_{1},b_{7},b_{6},b_{5},b_{4},b_{3},b_{2},b_{8}\right)\]

\end_inset

where 
\begin_inset Formula $b_{i}$
\end_inset

 is the byte of the hash at position 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Standard
Observe, that 
\begin_inset Formula $\pi$
\end_inset

 behaves similar as 
\begin_inset Formula $\alpha$
\end_inset

 by 
\begin_inset Quotes eld
\end_inset

rotating
\begin_inset Quotes erd
\end_inset

 the hash in 6 steps, while 
\begin_inset Formula $\rho$
\end_inset

 behaves similar as 
\begin_inset Formula $\beta$
\end_inset

 by 
\begin_inset Quotes eld
\end_inset

mirroring
\begin_inset Quotes erd
\end_inset

 the hash
\begin_inset Foot
status open

\begin_layout Plain Layout
This is surely no proof for isomorphism.
 Group theoretic proofs, however, are beyond the scope of this article and
 therefore left out.
\end_layout

\end_inset

.
 What is important about bitwise permutations is that they are invariant
 under the xor operation.
 Therefore we know that
\begin_inset Formula \begin{equation}
\pi\left(\text{zobrist}\left(\text{state}\right)\right)=\pi\left(\bigotimes_{f\in\mathbb{F}}\text{hash}\left(f,\text{state}\left(f\right)\right)\right)=\bigotimes_{f\in\mathbb{F}}\pi\left(\text{hash}\left(f,\text{state}\left(f\right)\right)\right)\label{eq:pi-invariant-xor}\end{equation}

\end_inset


\begin_inset Formula \begin{equation}
\rho\left(\text{zobrist}\left(\text{state}\right)\right)=\rho\left(\bigotimes_{f\in\mathbb{F}}\text{hash}\left(f,\text{state}\left(f\right)\right)\right)=\bigotimes_{f\in\mathbb{F}}\rho\left(\text{hash}\left(f,\text{state}\left(f\right)\right)\right)\label{eq:rho-invariant-xor}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
We now define that 
\begin_inset Formula $\pi\left(\text{zobrist}\left(\text{state}\right)\right)=\text{zobrist\left(\alpha\circ\text{state}\right)}$
\end_inset

 and 
\begin_inset Formula $\rho\left(\text{zobrist}\left(\text{state}\right)\right)=\text{zobrist\left(\beta\circ state\right)}$
\end_inset

.
 With equations 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:pi-invariant-xor"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rho-invariant-xor"

\end_inset

 that yields the following expressions:
\begin_inset Formula \begin{equation}
zobrist\left(\alpha\circ\text{state}\right)=\bigotimes_{f\in\mathbb{F}}\pi\left(\text{hash}\left(f,\text{state}\left(f\right)\right)\right)=\bigotimes_{f\in\mathbb{F}}\text{hash}\left(f,\alpha\circ\text{state}\left(f\right)\right)\label{eq:alpha-pi-equality}\end{equation}

\end_inset


\begin_inset Formula \begin{equation}
zobrist\left(\beta\circ\text{state}\right)=\bigotimes_{f\in\mathbb{F}}\rho\left(\text{hash}\left(f,\text{state}\left(f\right)\right)\right)=\bigotimes_{f\in\mathbb{F}}\text{hash}\left(f,\beta\circ\text{state}\left(f\right)\right)\label{eq:beta-rho-equality}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The most straightforward way to satisfy 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:alpha-pi-equality"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:beta-rho-equality"

\end_inset

is to put the following constraint on the 
\begin_inset Formula $\text{hash}\left(f,a\right)$
\end_inset

 function: 
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\text{hash}\left(f_{1},a\right)=\pi\left(\text{hash}\left(f_{2},a\right)\right)$
\end_inset

 if and only if 
\begin_inset Formula $\alpha\circ\text{state}\left(f_{2}\right)=\text{state\left(f_{1}\right)}$
\end_inset

 for all states.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\text{hash}\left(f_{1},a\right)=\rho\left(\text{hash}\left(f_{2},a\right)\right)$
\end_inset

 if and only if 
\begin_inset Formula $\beta\circ\text{state}\left(f_{2}\right)=\text{state\left(f_{1}\right)}$
\end_inset

 for all states.
\end_layout

\begin_layout Standard
As long as we know that those constraints are valid for our hash function,
 we can easily apply 
\begin_inset Formula $\pi$
\end_inset

 and 
\begin_inset Formula $\rho$
\end_inset

 on a known hash in order to get all it's symmetries.
 The problem that remains is how to enforce those constraints.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename abalone-board-symmetries.dia
	width 40col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Symmetries of the abalone board.
\begin_inset CommandInset label
LatexCommand label
name "fig:Symmetries"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Looking at the board in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Symmetries"

\end_inset

 reveals that there are two classes of symmetry axes - the ones that are
 odd numbered and marked by a light green line and the ones that are even
 numbered and marked by a dark green line.
 For the yellow nodes on the horizontal axis (1), we can apply the following
 constraint:
\begin_inset Formula \[
\beta=\alpha^{3}\]

\end_inset

which means that 
\begin_inset Formula $\rho=\pi^{3}$
\end_inset

.
 Looking at what this means for the bitwise permutation we get the following
 condition:
\begin_inset Formula \begin{eqnarray*}
\left(b_{1},b_{7},b_{6},b_{5},b_{4},b_{3},b_{2},b_{8}\right) & = & \left(b_{1},b_{3},b_{4},b_{5},b_{6},b_{7},b_{2},b_{8}\right)\end{eqnarray*}

\end_inset

which gives us
\begin_inset Formula \begin{eqnarray*}
b_{3} & = & b_{7}\\
b_{6} & = & b_{4}\end{eqnarray*}

\end_inset

so that we can derive the structure of the hashes on axis (1):
\begin_inset Formula \[
\left(b_{1},b_{2},b_{3},b_{2},b_{4},b_{5},b_{4},b_{6}\right)\]

\end_inset


\end_layout

\begin_layout Standard
Similarly we can derive the hash structures of axes (3) and (5):
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(b_{1},b_{2},b_{3},b_{4},b_{5},b_{4},b_{3},b_{6}\right)$
\end_inset

 for axis (3)
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(b_{1},b_{2},b_{3},b_{4},b_{3},b_{2},b_{5},b_{6}\right)$
\end_inset

 for axis (5)
\end_layout

\begin_layout Standard
The constraint we find on axis (4) is that 
\begin_inset Formula $\beta=e$
\end_inset

.
 Using the same approach as above we can derive the following structures:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(b_{1},b_{2},b_{3},b_{4},b_{4},b_{3},b_{2},b_{5}\right)$
\end_inset

 for axis (4)
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(b_{1},b_{2},b_{3},b_{3},b_{2},b_{4},b_{4},b_{5}\right)$
\end_inset

 for axis (6)
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(b_{1},b_{2},b_{2},b_{3},b_{4},b_{4},b_{3},b_{5}\right)$
\end_inset

 for axis (2)
\end_layout

\begin_layout Standard
Note that the structures actually allow us to apply 
\begin_inset Formula $\pi$
\end_inset

 three times on every node of one axis of each class in order to assign
 the correctly constrained values.
 Note also that we reduced the effective hash size to six byte on axis (1),
 (3) and (5) and to five byte on axis (2), (4) and (6).
\end_layout

\begin_layout Standard
There is one more special case, namely the central node whose hash has to
 stay invariant under 
\begin_inset Formula $\pi$
\end_inset

 and 
\begin_inset Formula $\rho$
\end_inset

.
 We therefore simply assign it a value with the structure 
\begin_inset Formula $\left(b_{1},b_{2},b_{2},b_{2},b_{2},b_{2},b_{2},b_{3}\right)$
\end_inset

.
 The hashes of the remaining nodes (colored blue in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Symmetries"

\end_inset

) are easily generated by generating random eight byte values and applying
 
\begin_inset Formula $\pi$
\end_inset

 and 
\begin_inset Formula $\rho$
\end_inset

 to derive all symmetries.
\end_layout

\begin_layout Subsection
Evaluation Functions
\begin_inset CommandInset label
LatexCommand label
name "sub:Evaluation-Functions"

\end_inset


\end_layout

\begin_layout Subsubsection
Linear Evaluation Functions
\begin_inset CommandInset label
LatexCommand label
name "sub:Linear-Evaluation-Functions"

\end_inset


\end_layout

\begin_layout Subsubsection
Simple Evaluator
\begin_inset CommandInset label
LatexCommand label
name "sub:Simple-Evaluator"

\end_inset


\end_layout

\begin_layout Subsubsection
Lemmen's Evaluator
\begin_inset CommandInset label
LatexCommand label
name "sub:Lemmen's-Evaluator"

\end_inset


\end_layout

\begin_layout Subsubsection
Non-Linear Evaluator
\begin_inset CommandInset label
LatexCommand label
name "sub:Non-Linear-Evaluator"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Genetic Algorithm
\begin_inset CommandInset label
LatexCommand label
name "sec:Genetic-Algorithm"

\end_inset


\end_layout

\begin_layout Subsection
Design
\begin_inset CommandInset label
LatexCommand label
name "sub:GA-Design"

\end_inset


\end_layout

\begin_layout Subsection
Implementation
\begin_inset CommandInset label
LatexCommand label
name "sub:GA-Implementation"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Opponent Modeling
\begin_inset CommandInset label
LatexCommand label
name "sec:Opponent-Modeling"

\end_inset


\end_layout

\begin_layout Standard
Normal minimax-search assumes the opponent will always make the optimal
 moves for him.
 He assumes the opponent is using the same evaluation function.
 With human opponents this is never the case but because the AI presumes
 the evaluation function is optimal, the human can only make worse decisions
 than the ones the AI had envisioned for him.
\end_layout

\begin_layout Standard
With opponent modeling the AI tries to get a greater advantage from the
 fact that the opponent makes sub-optimal moves (according to the minimax
 evaluation function).
 And the AI tries to get optimal outcomes knowing the opponent will make
 sub-optimal moves.
\end_layout

\begin_layout Subsection
Design
\begin_inset CommandInset label
LatexCommand label
name "sub:OpponentModeling-Design"

\end_inset


\end_layout

\begin_layout Standard
We make a difference between opponents that we already know and have a model
 of and opponents never seen before without any known model.
\end_layout

\begin_layout Standard
If we already know an opponent we can load his model into a new opponent-minimax
 AI that will incorperate the model in the search.
 The minimax can now make moves that might be suboptimal in normal minimax-searc
h but will give the new AI an advantage because the opponent will do a suboptima
l move which has a better "value" for the opponent-minimax AI.
\end_layout

\begin_layout Standard
If we don't know the opponent we try to adjust our current AI to make the
 choices the opponent makes logical.
 This way we try to make a model of the opponent which is compatible with
 out current model.
\end_layout

\begin_layout Subsection
Implementation
\begin_inset CommandInset label
LatexCommand label
name "sub:OpponentModeling-Implementation"

\end_inset


\end_layout

\begin_layout Standard
In our implementation a opponent model consists of the weights of the evaluation
 function, similar to the individuals of our genetic algorithm.
 Because of this the only way an opponent can differ from our own AI is
 different outcomes for all the moves.
\end_layout

\begin_layout Standard
The search-method we use with these opponent models is Opponent-model search[ref
].
 
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Experimental Setup
\begin_inset CommandInset label
LatexCommand label
name "sec:Experiments-Setup"

\end_inset


\end_layout

\begin_layout Subsection
Tree Search Performance
\begin_inset CommandInset label
LatexCommand label
name "sub:Setup-Tree-Search-Performance"

\end_inset


\end_layout

\begin_layout Standard
The experimental setup for the tree search performance aimed at measuring
 two criteria:
\end_layout

\begin_layout Enumerate
The time needed for a search run of a certain depth.
\end_layout

\begin_layout Enumerate
The nodes investigated during a search run of a certain depth.
\end_layout

\begin_layout Standard
While the latter criterion has the advantage of being independent of implementat
ions issues and more reproducible, the former criterion also takes into
 account overhead that might have been added by certain pruning techniques.
\end_layout

\begin_layout Standard
The problem of those measurements in the game of abalone is, that the complexity
 of a search strongly depends on several factors different from the applied
 optimization, as for example the number of possible moves in a state.
 To overcome this issue and provide a reliable result, multiple distinct
 statistics are collected:
\end_layout

\begin_layout Enumerate
The results of a search from the start position.
\end_layout

\begin_layout Enumerate
The results of a search from a typical in-game situation.
\end_layout

\begin_layout Enumerate
The averaged result of multiple searches throughout a game.
\end_layout

\begin_layout Standard
Having established the test strategy, it can be applied to the optimization
 techniques described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:General-Tree-Searching"

\end_inset

 including alpha-beta pruning, move ordering, Zobrist hashing and symmetry
 aware hashing.
\end_layout

\begin_layout Standard
The results are given in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Result-Tree-Search-Performance"

\end_inset

.
\end_layout

\begin_layout Subsection
Training of the Evaluation Function
\begin_inset CommandInset label
LatexCommand label
name "sub:Setup-Training-of-the"

\end_inset


\end_layout

\begin_layout Subsection
Overall AI Performance
\begin_inset CommandInset label
LatexCommand label
name "sub:Setup-AI-Performance"

\end_inset


\end_layout

\begin_layout Enumerate
Our AI vs ABA-PRO*
\end_layout

\begin_layout Enumerate
Our AI vs Random Software Abalone*
\end_layout

\begin_layout Enumerate
Out AI vs NetAbalone* 
\end_layout

\begin_layout Section
Results of Experiments
\begin_inset CommandInset label
LatexCommand label
name "sec:Results"

\end_inset


\end_layout

\begin_layout Subsection
Tree Search Performance
\begin_inset CommandInset label
LatexCommand label
name "sub:Result-Tree-Search-Performance"

\end_inset


\end_layout

\begin_layout Standard
In this section the results of experimental setup described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Setup-Tree-Search-Performance"

\end_inset

 will be given and interpreted.
 
\end_layout

\begin_layout Subsection
Training of the Evaluation Function
\begin_inset CommandInset label
LatexCommand label
name "sub:Result-Training-of-the-Evaluation"

\end_inset


\end_layout

\begin_layout Subsection
Overall AI Performance
\begin_inset CommandInset label
LatexCommand label
name "sub:Result-Overal-AI-Performance"

\end_inset


\end_layout

\begin_layout Section
Conclusions
\begin_inset CommandInset label
LatexCommand label
name "sec:Conclusions"

\end_inset


\end_layout

\begin_layout Section
Discussion and Further Research
\begin_inset CommandInset label
LatexCommand label
name "sec:Further-Research"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "bibliography"
options "bibtotoc,apalike2"

\end_inset


\end_layout

\begin_layout Section
\start_of_appendix
Result Tables for the Experimental Results
\end_layout

\begin_layout Subsection
Tree Search Performance
\end_layout

\begin_layout Subsection
Training of the Evaluation Function
\end_layout

\end_body
\end_document
